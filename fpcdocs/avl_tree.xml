<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="fcl">

<!--
  ====================================================================
    AVL_Tree
  ====================================================================
-->

<module name="AVL_Tree">
<short>AVL tree implementation</short>
<descr>
<p>The <var>avl_tree</var> unit implements a general-purpose AVL (balanced) tree class:
the <link id="TAVLTree"/> class and it's associated data node class <link
id="TAVLTreeNode"/>.</p>
</descr>

<!-- unresolved type reference Visibility: default -->
<element name="Classes">
<short>List classes</short>
</element>

<!-- unresolved type reference Visibility: default -->
<element name="SysUtils">
<short>Exception support and string handling</short>
</element>

<!--
  ********************************************************************
    #fcl.AVL_Tree.TAVLTreeNode
  ********************************************************************
-->

<!-- object Visibility: default -->
<element name="TAVLTreeNode">
<short>Represents a node in the tree.</short>
<descr>
<var>TAVLTreeNode</var> represents a single node in the AVL tree. It
contains references to the other nodes in the tree, and provides a 
<link id="TAVLTreeNode.Data">Data</link> pointer which can be used to store
the data, associated with the node.
</descr>
<seealso>
<link id="TAVLTree"/>
<link id="TAVLTreeNode.Data"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TAVLTreeNode.Parent">
<short>Reference to the parent node in the tree.</short>
<descr>
<var>Parent</var> contains a reference to the parent node of the current
node. It is <var>Nil</var> for the root node.
</descr>
<seealso>
<link id="TAVLTreeNode.Left">left</link>
<link id="TAVLTreeNode.Right">Right</link>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TAVLTreeNode.Left">
<short>Reference to the left subtree of the current node.</short>
<descr>
<var>Left</var> contains a reference to the first node in the left subtree
of the current node. It is <var>Nil</var> if there is no left subtree.
</descr>
<seealso>
<link id="TAVLTreeNode.Parent">Parent</link>
<link id="TAVLTreeNode.Right">Right</link>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TAVLTreeNode.Right">
<short>Reference to the right subtree of the current node.</short>
<descr>
<var>Right</var> contains a reference to the first node in the right subtree
of the current node. It is <var>Nil</var> if there is no right subtree.
</descr>
<seealso>
<link id="TAVLTreeNode.Parent">Parent</link>
<link id="TAVLTreeNode.Left">Left</link>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TAVLTreeNode.Balance">
<short>Balance of the current node</short>
<descr>
<var>Balance</var> is the balance of the current node, that is, the <link
id="TAVLTreeNode.TreeDepth">Depth</link> of the right subtree minus the 
depth of the left subtree. If <var>balance</var> is one of -1, 0, 1 then 
the node is considered balanced.
</descr>
<seealso>
<link id="TAVLTreeNode.TreeDepth">TreeDepth</link>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TAVLTreeNode.Data">
<short>The data item associated with this node.</short>
<descr>
<var>Data</var> is the data item associated with this node. It is not freed
when the node is freed, the programmer is responsible for freeing the actual
data.
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTreeNode.Clear">
<short>Clears the node's data</short>
<descr>
<var>Clear</var> clears all pointers and references in the node. It does not
free the memory pointed to by these references.
</descr>
</element>

<!-- function Visibility: public -->
<element name="TAVLTreeNode.TreeDepth">
<short>Level of the node in the tree below</short>
<descr>
<var>TreeDepth</var> is the height of the node: this is the largest height of
the left or right nodes, plus 1. If no nodes appear below this node
(<var>left</var> and <var>Right</var> are <var>Nil</var>), the depth
is 1.
</descr>
<seealso>
<link id="TAVLTreeNode.Balance">Balance</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTreeNode.TreeDepth.Result">
<short>The depth of the current node</short>
</element>

<!-- constructor Visibility: public -->
<element name="TAVLTreeNode.Create">
<short>Create a new node instance</short>
<descr>
Create a new tree node instance. 
</descr>
</element>

<!-- destructor Visibility: public -->
<element name="TAVLTreeNode.Destroy">
<short>Free the node</short>
<descr>
<var>Destroy</var> frees the current node. It does not free the left or
right or data nodes.
</descr>
<seealso>
<link id="TAVLTreeNode.Clear">Clear</link>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.AVL_Tree.TAVLTree
  ********************************************************************
-->

<!-- object Visibility: default -->
<element name="TAVLTree">
<short>AVL tree component</short>
<descr>
<p>
<var>TAVLTree</var> maintains a balanced AVL tree. The tree consists of <link
id="TAVLTreeNode"/> nodes, each of which has a <var>Data</var> pointer 
associated with it. The <var>TAVLTree</var> component offers methods to
balance and search the tree.
</p>
<p>
By default, the list is searched with a simple pointer comparison algorithm, 
but a custom search mechanism can be specified in the <link
id="TAVLTree.OnCompare">OnCompare</link> property.
</p>
</descr>
<seealso>
<link id="TAVLTreeNode"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TAVLTree.Root">
<short>Root node of the tree</short>
<descr>
<var>Root</var> is the root node of the tree. It should not be set
explicitly, only use the <link id="TAVLTree.Add">Add</link>,
<link id="TAVLTree.Delete">Delete</link>, 
<link id="TAVLTree.Remove">Remove</link>, 
<link id="TAVLTree.RemovePointer">RemovePointer</link>, 
or <link id="TAVLTree.Clear">Clear</link> methods to manipulate the items in the
tree.
</descr>
<seealso>
<link id="TAVLTree.Add"/>
<link id="TAVLTree.Delete"/>
<link id="TAVLTree.Remove"/>
<link id="TAVLTree.RemovePointer"/>
<link id="TAVLTree.Clear"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.Find">
<short>Find a data item in the tree.</short>
<descr>
<p>
<var>Find</var> uses the default <link id="TAVLTree.OnCompare">OnCompare</link>
comparing function to find the <var>Data</var> pointer in the tree.
It returns the <var>TAVLTreeNode</var> instance that results in a successful
compare with the <var>Data</var> pointer, or <var>Nil</var> if none is found.
</p>
<p>
The default <var>OnCompare</var> function compares the actual pointers,
which means that by default <var>Find</var> will give the same result
as <link id="TAVLTree.FindPointer">FindPointer</link>.
</p>
</descr>
<seealso>
<link id="TAVLTree.OnCompare">OnCompare</link>
<link id="TAVLTree.FindKey">FindKey</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.Find.Result">
<short>Tree node corresponding to <var>Data</var> item.</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.Find.Data">
<short>Data item to search for.</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindKey">
<short>Find a data item in the tree using alternate compare mechanism</short>
<descr>
<var>FindKey</var> uses the specified <var>OnCompareKeyWithData</var>
comparing function to find the <var>Key</var> pointer in the tree
It returns the <var>TAVLTreeNode</var> instance that matches the
<var>Data</var> pointer, or <var>Nil</var> if none is found.
</descr>
<seealso>
<link id="TAVLTree.OnCompare">OnCompare</link>
<link id="TAVLTree.Find">Find</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindKey.Result">
<short>Tree node corresponding to <var>Key</var> item.</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindKey.Key">
<short>Data item to search for.</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindKey.OnCompareKeyWithData">
<short>Data pointer comparison callback</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindSuccessor">
<short>Find successor to node</short>
<descr>
<p>
<var>FindSuccessor</var> returns the successor to <var>ANode</var>: this is the
leftmost node in the right subtree, or the leftmost node above the node
<var>ANode</var>. This can of course be <var>Nil</var>.
</p>
<p>
This method is used when a node must be inserted at the rightmost position.
</p>
</descr>
<seealso>
<link id="TAVLTree.FindPrecessor"/>
<link id="TAVLTree.MoveDataRightMost"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindSuccessor.Result">
<short>The succeeding node</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindSuccessor.ANode">
<short>The node from which to start the search</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindPrecessor">
<short></short>
<descr>
<p>
<var>FindPrecessor</var> returns the successor to <var>ANode</var>: this is
the rightmost node in the left subtree, or the rightmost node above the node
<var>ANode</var>. This can of course be <var>Nil</var>.
</p>
<p>
This method is used when a node must be inserted at the leftmost position.
</p>
</descr>
<seealso>
<link id="TAVLTree.FindSuccessor"/>
<link id="TAVLTree.MoveDataLeftMost"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindPrecessor.Result">
<short>The preceding node</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindPrecessor.ANode">
<short>The node from which to start the search</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindLowest">
<short>Find the lowest (leftmost) node in the tree.</short>
<descr>
<var>FindLowest</var> returns the leftmost node in the tree, i.e. the node
which is reached when descending from the rootnode via the <link
id="TAVLTreeNode.Left">left</link> subtrees.
</descr>
<seealso>
<link id="TAVLTree.FindHighest">FindHighest</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindLowest.Result">
<short>The leftmost (lowest) node in the tree.</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindHighest">
<short>Find the highest (rightmost) node in the tree.</short>
<descr>
<var>FindHighest</var> returns the rightmost node in the tree, i.e. the node
which is reached when descending from the rootnode via the <link
id="TAVLTreeNode.Right">Right</link> subtrees.
</descr>
<seealso>
<link id="TAVLTree.FindLowest">FindLowest</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindHighest.Result">
<short>The rightmost (highest) node in the tree.</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindNearest">
<short>Find the node closest to the data in the tree</short>
<descr>
<var>FindNearest</var> searches the node in the data tree that is closest to
the specified <var>Data</var>. If <var>Data</var> appears in the tree, then
its node is returned.
</descr>
<seealso>
<link id="TAVLTree.FindHighest">FindHighest</link>
<link id="TAVLTree.FindLowest">FindLowest</link>
<link id="TAVLTree.Find">Find</link>
<link id="TAVLTree.FindKey">FindKey</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindNearest.Result">
<short>The node that is closest to <var>Data</var></short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindNearest.Data">
<short>The data item to search for.</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindPointer">
<short>Search for a data pointer</short>
<descr>
<p>
<var>FindPointer</var> searches for a node where the actual data pointer
equals <var>Data</var>. This is a more fine search than <link
id="TAVLTree.Find">find</link>, where a custom compare function can be used.
</p>
<p>
The default <link id="TAVLTree.OnCompare">OnCompare</link> compares the data
pointers, so the default <var>Find</var> will return the same node as
<var>FindPointer</var>
</p>
</descr>
<seealso>
<link id="TAVLTree.Find"/>
<link id="TAVLTree.FindKey"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindPointer.Result">
<short>The node that matches <var>Data</var></short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindPointer.Data">
<short>The data pointer to search for.</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindLeftMost">
<short>Find the node most left to a specified data node</short>
<descr>
<p>
<var>FindLeftMost</var> finds the node most left from the 
<var>Data</var> node. It starts at the preceding node 
for <var>Data</var> and tries to move as far right in the 
tree as possible.
</p>
<p>
This operation corresponds to finding the previous item in a list.
</p>
</descr>
<seealso>
<link id="TAVLTree.FindRightMost"/>
<link id="TAVLTree.FindLeftMostKey"/>
<link id="TAVLTree.FindRightMostKey"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindLeftMost.Result">
<short>The leftmost node relative to <var>Data</var></short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindLeftMost.Data">
<short>The data item where to start the search from</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindRightMost">
<short>Find the node most right to a specified node</short>
<descr>
<p>
<var>FindRightMost</var> finds the node most right from the
<var>Data</var> node. It starts at the succeeding node for 
<var>Data</var> and tries to move as far left in the tree 
as possible.
</p>
<p>
This operation corresponds to finding the next item in a list.
</p>
</descr>
<seealso>
<link id="TAVLTree.FindLeftMost"/>
<link id="TAVLTree.FindLeftMostKey"/>
<link id="TAVLTree.FindRightMostKey"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindRightMost.Result">
<short>The rightmost node relative to <var>Data</var></short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindRightMost.Data">
<short>The data item where to start the search from</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindLeftMostKey">
<short>Find the node most left to a specified key node</short>
<descr>
<var>FindLeftMostKey</var> finds the node most left from the
node associated with <var>Key</var>. It starts at the preceding node
for <var>Key</var> and tries to move as far left in the
tree as possible.
</descr>
<seealso>
<link id="TAVLTree.FindLeftMost"/>
<link id="TAVLTree.FindRightMost"/>
<link id="TAVLTree.FindRightMostKey"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindLeftMostKey.Result">
<short>The leftmost node for <var>Key</var></short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindLeftMostKey.Key">
<short>Key identifying the node where to start the search.</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindLeftMostKey.OnCompareKeyWithData">
<short>Callback to compare key value with data item</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindRightMostKey">
<short>Find the node most right to a specified key node</short>
<descr>
<var>FindRightMostKey</var> finds the node most left from the
node associated with <var>Key</var>. It starts at the succeeding node
for <var>Key</var> and tries to move as far right in the
tree as possible.
</descr>
<seealso>
<link id="TAVLTree.FindLeftMost"/>
<link id="TAVLTree.FindRightMost"/>
<link id="TAVLTree.FindLeftMostKey"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindRightMostKey.Result">
<short>The rightmost node for <var>Key</var></short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindRightMostKey.Key">
<short>Key identifying the node where to start the search.</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindRightMostKey.OnCompareKeyWithData">
<short>Callback to compare key value with data item</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindLeftMostSameKey">
<short>Find the node most left to a specified node with the same data</short>
<descr>
<var>FindLefMostSameKey</var> finds the node most left from and with the same
data as the specified node <var>ANode</var>.
</descr>
<seealso>
<link id="TAVLTree.FindLeftMost"/>
<link id="TAVLTree.FindLeftMostKey"/>
<link id="TAVLTree.FindRightMostSameKey"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindLeftMostSameKey.Result">
<short>The treenode that was found, or nil if none found</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindLeftMostSameKey.ANode">
<short>The node to start the search from</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindRightMostSameKey">
<short>Find the node most right of a specified node with the same data</short>
<descr>
<var>FindRighMostSameKey</var> finds the node most right from and with the
same data as the specified node <var>ANode</var>.
</descr>
<seealso>
<link id="TAVLTree.FindRightMost"/>
<link id="TAVLTree.FindRightMostKey"/>
<link id="TAVLTree.FindLeftMostSameKey"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindRightMostSameKey.Result">
<short>The treenode that was found, or nil if none found</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindRightMostSameKey.ANode">
<short>The node to start the search from</short>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTree.Add">
<short>Add a new node to the tree</short>
<descr>
<var>Add</var> adds a new <var>Data</var> or <var>Node</var> to the tree. 
It inserts the node so that the tree is maximally balanced by rebalancing
the tree after the insert. In case a <var>data</var> pointer is added to 
the tree, then the node that was created is returned.
</descr>
<seealso>
<link id="TAVLTree.Delete"/>
<link id="TAVLTree.Remove"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.Add.ANode">
<short>Node to add to the tree</short>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.Add.Result">
<short>Resulting node in case a data pointer is added.</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.Add.Data">
<short>Data item to add to the tree</short>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTree.Delete">
<short>Delete a node from the tree</short>
<descr>
<p>
<var>Delete</var> removes the node from the tree. The node is not freed, but
is passed to a <link id="TAVLTreeNodeMemManager"/> instance for future
reuse. The data that the node represents is also not freed.
</p>
<p>
The tree is rebalanced after the node was deleted.
</p>
</descr>
<seealso>
<link id="TAVLTree.Remove"/>
<link id="TAVLTree.RemovePointer"/>
<link id="TAVLTree.Clear"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.Delete.ANode">
<short>The node to delete from the tree.</short>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTree.Remove">
<short>Remove a data item from the list.</short>
<descr>
<var>Remove</var> finds the node associated with <var>Data</var> using
<link id="TAVLTree.Find">find</link> and, 
if found, deletes it from the tree. Only the first occurrence of
<var>Data</var> will be removed.
</descr>
<seealso>
<link id="TAVLTree.Delete"/>
<link id="TAVLTree.RemovePointer"/>
<link id="TAVLTree.Clear"/>
<link id="TAVLTree.Find"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.Remove.Data">
<short>Data item to remove from the tree.</short>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTree.RemovePointer">
<short>Remove a pointer item from the list.</short>
<descr>
<var>Remove</var> uses <link id="TAVLTree.FindPointer">FindPointer</link> to find the node associated with
the pointer <var>Data</var> and, if found, deletes it from the tree. Only the first 
occurrence of <var>Data</var> will be removed.
</descr>
<seealso>
<link id="TAVLTree.Remove"/>
<link id="TAVLTree.Delete"/>
<link id="TAVLTree.Clear"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.RemovePointer.Data">
<short>Pointer to remove from the tree</short>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTree.MoveDataLeftMost">
<short>Move data to the nearest left element</short>
<descr>
<p>
<var>MoveDataLeftMost</var> moves the data from the node <var>ANode</var> to the
nearest left location relative to <var>Anode</var>. It returns the new node where 
the data is positioned. The data from the former left node will be switched to 
<var>ANode</var>.
</p>
<p>
This operation corresponds to switching the current with the previous
element in a list.
</p>
</descr>
<seealso>
<link id="TAVLTree.MoveDataRightMost"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.MoveDataLeftMost.ANode">
<short>Node whose data most be moved</short>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTree.MoveDataRightMost">
<short>Move data to the nearest right element</short>
<descr>
<p>
<var>MoveDataRightMost</var> moves the data from the node <var>ANode</var> to the
rightmost location relative to <var>Anode</var>. It returns the new node where the data is positioned.
The data from the former rightmost node will be switched to <var>ANode</var>.
</p>
<p>
This operation corresponds to switching the current with the next
element in a list.
</p>
</descr>
<seealso>
<link id="TAVLTree.MoveDataLeftMost"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.MoveDataRightMost.ANode">
<short>Node whose data most be moved</short>
</element>

<!-- property Visibility: public -->
<element name="TAVLTree.OnCompare">
<short>Compare function used when comparing nodes</short>
<descr>
<var>OnCompare</var> is the comparing function used when the data of 2 nodes 
must be compared. By default, the function simply compares the 2 data
pointers. A different function can be specified on creation.
</descr>
<seealso>
<link id="TAVLTree.Create"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTree.Clear">
<short>Clears the tree</short>
<descr>
<p>
<var>Clear</var> deletes all nodes from the tree. The nodes themselves
are not freed, and the data pointer in the nodes is also not freed.
</p>
<p>
If the node's data must be freed as well, use <link id="TAVLTree.FreeAndClear"/>
instead.
</p>
</descr>
<seealso>
<link id="TAVLTree.FreeAndClear"/>
<link id="TAVLTree.Delete"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTree.FreeAndClear">
<short>Clears the tree and frees nodes</short>
<descr>
<var>FreeAndClear</var> deletes all nodes from the tree. 
The data pointer in the nodes is assumed to be an object, and is freed prior
to deleting the node from the tree.
</descr>
<seealso>
<link id="TAVLTree.Clear"/>
<link id="TAVLTree.Delete"/>
<link id="TAVLTree.FreeAndDelete"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTree.FreeAndDelete">
<short>Delete a node from the tree and destroy it</short>
<descr>
<var>FreeAndDelete</var> deletes a node from the tree, and destroys the data
pointer: The data pointer in the nodes is assumed to be an object, and is
freed by calling its destructor.
</descr>
<seealso>
<link id="TAVLTree.Clear"/>
<link id="TAVLTree.Delete"/>
<link id="TAVLTree.FreeAndClear"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FreeAndDelete.ANode">
<short>Node which must be deleted</short>
</element>

<!-- property Visibility: public -->
<element name="TAVLTree.Count">
<short>Number of nodes in the tree.</short>
<descr>
<var>Count</var> is the number of nodes in the tree.
</descr>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.ConsistencyCheck">
<short>Check the consistency of the tree</short>
<descr>
<p>
<var>ConsistencyCheck</var> checks the correctness of the tree. It returns 0
if the tree is internally consistent, and a negative number if the tree
contains an error somewhere.
</p>
<dl>
<dt>-1</dt><dd>The Count property doesn't match the actual node count</dd>
<dt>-2</dt><dd>A left node does not point to the correct parent</dd>
<dt>-3</dt><dd>A left node is larger than parent node</dd>
<dt>-4</dt><dd>A right node does not point to the correct parent</dd>
<dt>-5</dt><dd>A right node is less than parent node</dd>
<dt>-6</dt><dd>The balance of a node is not calculated correctly</dd>
</dl>
</descr>
<seealso>
<link id="TAVLTree.WriteReportToStream"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.ConsistencyCheck.Result">
<short>0 if the tree is OK, a negative number if something is wrong.</short>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTree.WriteReportToStream">
<short>Write the contents of the tree consistency check to the stream</short>
<descr>
<var>WriteReportToStream</var> writes a visual representation of the tree to
the stream <var>S</var>. The total number of written bytes is returned in
<var>StreamSize</var>. This method is only useful for debugging purposes.
</descr>
<seealso>
<link id="TAVLTree.ConsistencyCheck"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.WriteReportToStream.s">
<short>Stream to write the tree report to</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.WriteReportToStream.StreamSize">
<short>Total number of bytes written</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.ReportAsString">
<short>Return the tree report as a string</short>
<descr>
<var>ReportAsString</var> calls <link id="TAVLTree.WriteReportToStream">WriteReportToStream</link>
and returns the stream data as a string.
</descr>
<seealso>
<link id="TAVLTree.WriteReportToStream"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.ReportAsString.Result">
<short>The tree report as a string</short>
</element>

<!-- constructor Visibility: public -->
<element name="TAVLTree.Create">
<short>Create a new instance of <var>TAVLTree</var></short>
<descr>
<var>Create</var> initializes a new instance of <link id="TAVLTree"/>. 
An alternate <link id="TAVLTree.OnCompare">OnCompare</link> can be provided: the
default <var>OnCompare</var> method compares the 2 data pointers of a node.
</descr>
<seealso>
<link id="TAVLTree.OnCompare">OnCompare</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.Create.OnCompareMethod">
<short>Alternative node comparison method</short>
</element>

<!-- destructor Visibility: public -->
<element name="TAVLTree.Destroy">
<short>Destroy the <var>TAVLTree</var> instance</short>
<descr>
<var>Destroy</var> clears the nodes (the node data is not freed) and then
destroys the <var>TAVLTree</var> instance.
</descr>
<seealso>
<link id="TAVLTree.Create"/>
<link id="TAVLTree.Clean"/>
</seealso>
</element>

<!--
  ********************************************************************
    #fcl.AVL_Tree.TAVLTreeNodeMemManager
  ********************************************************************
-->

<!-- object Visibility: default -->
<element name="TAVLTreeNodeMemManager">
<short><var>TAVLTreeNode</var> Node memory manager</short>
<descr>
<var>TAVLTreeNodeMemManager</var> is an internal object used by the
<file>avl_tree</file> unit. Normally, no instance of this object should be
created: An instance is created by the unit initialization code, and freed
when the unit is finalized.
</descr>
<seealso>
<link id="TAVLTreeNode"/>
<link id="TAVLTree"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTreeNodeMemManager.DisposeNode">
<short>Return a node to the free list</short>
<descr>
<p>
<var>DisposeNode</var> is used to put the node <var>ANode</var> in the list of free nodes, or
optionally destroy it if the free list is full. After a call to <var>DisposeNode</var>,
<var>ANode</var> must be considered invalid.
</p>
</descr>
<seealso>
<link id="TAVLTreeNodeMemManager.NewNode"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTreeNodeMemManager.DisposeNode.ANode">
<short>Node to dispose of</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTreeNodeMemManager.NewNode">
<short>Create a new <var>TAVLTreeNode</var> instance</short>
<descr>
<var>NewNode</var> returns a new <link id="TAVLTreeNode"/> instance.
If there is a node in the free list, it is returned. If no more free
nodes are present, a new node is created.
</descr>
<seealso>
<link id="TAVLTreeNodeMemManager.DisposeNode"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTreeNodeMemManager.NewNode.Result">
<short>The new node.</short>
</element>

<!-- property Visibility: public -->
<element name="TAVLTreeNodeMemManager.MinimumFreeNode">
<short>Minimum amount of free nodes to be kept.</short>
<descr>
<var>MinimumFreeNode</var> is the minimum amount of nodes that must be kept
in the free nodes list.
</descr>
<seealso>
<link id="TAVLTreeNodeMemManager.MaximumFreeNodeRatio"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TAVLTreeNodeMemManager.MaximumFreeNodeRatio">
<short>Maximum amount of free nodes in the list</short>
<descr>
<var>MaximumFreeNodeRatio</var> is the maximum amount of free nodes that
should be kept in the list: if a node is disposed of, then the ratio of
the free nodes versus the total amount of nodes is checked, and if it
is less than the <var>MaximumFreeNodeRatio</var> ratio but larger than
the minimum amount of free nodes, then the node
is disposed of instead of added to the free list.
</descr>
<seealso>
<link id="TAVLTreeNodeMemManager.Count"/>
<link id="TAVLTreeNodeMemManager.MinimumFreeNode"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TAVLTreeNodeMemManager.Count">
<short>Number of nodes in the list.</short>
<descr>
<var>Count</var> is the total number of nodes in the list, used or not.
</descr>
<seealso>
<link id="TAVLTreeNodeMemManager.MinimumFreeNode"/>
<link id="TAVLTreeNodeMemManager.MaximumFreeNodeRatio"/>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTreeNodeMemManager.Clear">
<short>Frees all unused nodes</short>
<descr>
<var>Clear</var> removes all unused nodes from the list and frees them.
</descr>
<seealso>
<link id="TAVLTreeNodeMemManager.MinimumFreeNode"/>
<link id="TAVLTreeNodeMemManager.MaximumFreeNodeRatio"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TAVLTreeNodeMemManager.Create">
<short>Create a new instance of <var>TAVLTreeNodeMemManager</var></short>
<descr>
<var>Create</var> initializes a new instance of <var>TAVLTreeNodeMemManager</var>.
</descr>
<seealso>
<link id="TAVLTreeNodeMemManager.Destroy"/>
</seealso>
</element>

<!-- destructor Visibility: public -->
<element name="TAVLTreeNodeMemManager.Destroy">
<short></short>
<descr>
<var>Destroy</var> calls clear to clean up the free node list 
and then calls the inherited destroy. 
</descr>
<seealso>
<link id="TAVLTreeNodeMemManager.Create"/>
</seealso>
</element>

<element name="TBaseAVLTreeNodeManager">
<short>Base class for a node memory manager</short>
<descr>
<p>
<var>TBaseAVLTreeNodeManager</var> is an abstract class from which a
descendent can be created that manages creating and disposing of tree 
nodes (instances of <link id="TAVLTreeNode"/>) for a <link id="TAVLTree"/> tree instance. 
No instance of this class should be created, it is a purely
abstract class. The default descendant of this class used by an
<var>TAVLTree</var> instance is <link id="TAVLTreeNodeMemManager"/>.
</p>
<p>
The <link id="TAVLTree.SetNodeManager"/> method can be used to set the node
manager that a <var>TAVLTree</var> instance should use.
</p>
</descr>
<seealso>
<link id="TAVLTreeNodeMemManager"/>
<link id="TAVLTree.SetNodeManager"/>
<link id="TAVLTreeNode"/>
</seealso>
</element>

<element name="TBaseAVLTreeNodeManager.NewNode">
<short>Called when the AVL tree needs a new node</short>
<descr>
<var>NewNode</var> is called by <link id="TAVLTree"/> when it needs a new
node in <link id="TAVLTree.Add"/>. It must be implemented by descendants
to return a new <link id="TAVLTreeNode"/> instance.
</descr>
<seealso>
<link id="TBaseAVLTreeNodeManager.DisposeNode"/>
<link id="TAVLTree.Add"/>
<link id="TAVLTreeNode"/>
</seealso>
</element>

<element name="TBaseAVLTreeNodeManager.DisposeNode">
<short>Called when the AVL tree no longer needs node</short>
<descr>
<var>DisposeNode</var> is called by <link id="TAVLTree"/> when it no longer
needs a <link id="TAVLTreeNode"/> instance. The manager may decide to re-use
the instance for later use instead of destroying it.
</descr> 
<seealso>
<link id="TBaseAVLTreeNodeManager.NewNode"/>
<link id="TAVLTree.Delete"/>
<link id="TAVLTreeNode"/> 
</seealso>
</element>

<element name="TAVLTree.SetNodeManager">
<short>Set the node instance manager to use</short>
<descr>
<p>
<var>SetNodeManager</var> sets the node manager instance used by the tree to
<var>newmgr</var>. It should be called before any nodes are added to the
tree. The <var>TAVLTree</var> instance will not destroy the nodemanager, 
thus the same instance of the tree node manager can be used to
manager the nodes of multiple <var>TAVLTree</var> instances.
</p>
<p>
By default, a single instance of <link id="TAVLTreeNodeMemManager"/> is used to
manage the nodes of all <var>TAVLTree</var> instances.
</p>
</descr>
<seealso>
<link id="TBaseAVLTreeNodeManager"/>
<link id="TAVLTreeNodeMemManager"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TBaseAVLTreeNodeManager.DisposeNode.ANode">
<short>Node to dispose of</short>
</element>

<!-- function result Visibility: default -->
<element name="TBaseAVLTreeNodeManager.NewNode.Result">
<short>New node instance</short>
</element>

<!--
  ********************************************************************
    #fcl.AVL_Tree.TAVLTreeNodeEnumerator
  ********************************************************************
-->

<!-- class Visibility: default -->
<element name="TAVLTreeNodeEnumerator">
<short>Enumerator for the TAVLTree tree nodes</short>
<descr>
<var>TAVLTreeNodeEnumerator</var> is a class which implements the enumerator
interface for the <link id="TAVLTree"/>. It enumerates all the nodes in the tree.
</descr>
<seealso>
<link id="TAVLTree"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TAVLTreeNodeEnumerator.Create">
<short>Create a new instance of TAVLTreeNodeEnumerator</short>
<descr>
<var>Create</var> creates a new instance of <var>TAVLTreeNodeEnumerator</var>
and saves the <var>Tree</var> argument for later use in the enumerator.
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTreeNodeEnumerator.Create.Tree">
<short>TAVLTree instance to enumerate</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTreeNodeEnumerator.MoveNext">
<short>Move to next node in the tree.</short>
<descr>
<var>MoveNext</var> will return the lowest node in the tree to start with,
and for all other calls returns the successor node of the current node with
<link id="TAVLTree.FindSuccessor"/>.
</descr>
<seealso>
<link id="TAVLTree.FindSuccessor"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTreeNodeEnumerator.MoveNext.Result">
<short>Next node.</short>
</element>

<!-- property Visibility: public -->
<element name="TAVLTreeNodeEnumerator.Current">
<short>Current node in the tree</short>
<descr>
<var>Current</var> is the current node in the enumeration.
</descr>
<seealso>
<link id="TAVLTreeNodeEnumerator.MoveNext"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.SetNodeManager.NewMgr">
<short>New node manager to use</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.SetNodeManager.AutoFree">
<short>Automatically free the node manager when the tree is destroyed.</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.GetEnumerator">
<short>Get an enumerator for the tree.</short>
<descr>
<var>GetEnumerator</var> returns an instance of the standard tree node
enumerator <link id="TAVLTreeNodeEnumerator"/>.
</descr>
<seealso>
<link id="TAVLTreeNodeEnumerator"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.GetEnumerator.Result">
<short>An instance of an enumerator class.</short>
</element>

<!-- function type Visibility: default -->
<element name="TObjectSortCompare">
<short>Custom sort callback handler</short>
<descr>
<var>TObjectSortCompare</var> is the prototype for the <link id="TAVLTree.OnObjectCompare"/> property.
When assigned, it is used to sort the elements in the tree. It provides more information than the 
standard <var>TListSortCompare</var> handler used in <link id="TAVLTree.OnCompare"/>: 
it also passes the tree to the sort mechanism.
</descr>
<seealso>
<link id="TAVLTree.OnObjectCompare"/>
<link id="TAVLTree.OnCompare"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TObjectSortCompare.Result">
<short>one of -1, 0 or 1 depending on the comparison of <var>data1</var> and <var>data2</var></short>
</element>

<!-- argument Visibility: default -->
<element name="TObjectSortCompare.Tree">
<short>Tree that is comparing objects</short>
</element>

<!-- argument Visibility: default -->
<element name="TObjectSortCompare.Data1">
<short>First object</short>
</element>

<!-- argument Visibility: default -->
<element name="TObjectSortCompare.Data2">
<short>Second object</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTreeNode.Successor">
<short>Succeeding node in the tree</short>
<descr>
<var>Successor</var> calculates and return the succeeding (right) node in the tree. For the last node, Nil is returned.
</descr>
<seealso>
<link id="TAVLTreeNode.Precessor"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTreeNode.Successor.Result">
<short>The sucessor node</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTreeNode.Precessor">
<short>Preceding node in the tree</short>
<descr>
<var>Precessor</var> calculates and return the preceding (left) node in the tree. For the first node, Nil is returned.
</descr>
<seealso>
<link id="TAVLTreeNode.Successor"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTreeNode.Precessor.Result">
<short>The preceding node</short>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTreeNode.ConsistencyCheck">
<short>Check consistency of the node and below nodes.</short>
<descr>
<var>ConsistencyCheck</var> checks whether the node and nodes below are consistent, i.e. the nodes are still ordered correctly: left nodes are before right nodes.
</descr>
<errors>
If an inconsistency is detected, an exception is raised.
</errors>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTreeNode.ConsistencyCheck.Tree">
<short>Tree to which node belongs</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTreeNode.GetCount">
<short>Get the number of nodes</short>
<descr>
<var>GetCount</var> returns 1 plus the number of subnodes, if any.
</descr>
<errors>
None.
</errors>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTreeNode.GetCount.Result">
<short>The number of nodes in the subtree, starting from the current</short>
</element>

<!-- "class of" type Visibility: default -->
<element name="TAVLTreeNodeClass">
<short>Class of <var>TAVLTreeNode</var></short>
<descr>
<var>TAVLTreeNodeClass</var> is the class of <link id="TAVLTreeNode"/>. It is the type of the <link id="TAVLTree.NodeClass"/> property and determines what class of nodes will be created by the tree.
</descr>
<seealso>
<link id="TAVLTreeNode"/>
<link id="TAVLTree.NodeClass"/>
<link id="TAVLTree"/> 
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PAVLTreeNode">
<short>Pointer to TAVLTreeNode</short>
<seealso>
<link id="TAVLTreeNode"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTreeNodeEnumerator.Create.aLowToHigh">
<short>Should the tree be enumerated from low to high or not</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTreeNodeEnumerator.GetEnumerator">
<short>Returns the enumerator</short>
<descr>
<var>GetEnumerator</var> returns <var>Self</var>..
</descr>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTreeNodeEnumerator.GetEnumerator.Result">
<short>Self</short>
</element>

<!-- property Visibility: public -->
<element name="TAVLTreeNodeEnumerator.LowToHigh">
<short>Should the enumerator return nodes from low to high or high to low</short>
<descr>
<var>LowToHigh</var> determines whether the tree is walked from low to high or high to low. 
It's value is set in the constructor and cannot be changed while enumerating the tree nodes.
</descr>
<seealso>
<link id="TAVLTreeNodeEnumerator.Create"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TAVLTree.CreateObjectCompare">
<short>Create an instance of the tree with extended compare method</short>
<descr>
<var>CreateObjectCompare</var> is an alternative constructor that accepts 
a <link id="TObjectSortCompare"/> compare function instead of a regular <var>TListSortCompare</var> compare function.
The compare function can still be set in the <link id="TAVLTree.OnObjectCompare"/> property.
</descr>
<seealso>
<link id="TAVLTree.OnObjectCompare"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.CreateObjectCompare.OnCompareMethod">
<short>The value for the <var>OnObjectCompare</var> </short>
</element>

<!-- property Visibility: public -->
<element name="TAVLTree.OnObjectCompare">
<short>Compare handler</short>
<descr>
<var>OnObjectCompare</var> is used to compare nodes. It is only used if <link id="TAVLTree.OnCompare"/> is not set. 
</descr>
<seealso>
<link id="TAVLTree.OnCompare"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TAVLTree.NodeClass">
<short>Node class to create</short>
<descr>
<var>NodeClass</var> is the class of nodes to create when adding new nodes: 
<link id="TAVLTree.NewNode"/> will use this class when creating a new node. 
This can be set to a descendent class of <link id="TAVLTreeNode"/>,
 but not if there are already nodes in the tree.
</descr>
<seealso>
<link id="TAVLTreeNode"/>
<link id="TAVLTree.NewNode"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.NewNode">
<short>Create a new tree node</short>
<descr>
<var>NewNode</var> creates a new node, but does not insert it in the tree. 
It will use the node manager if that is set. 
If it is not set then the <link id="TAVLTree.NodeClass"/> class is used to create a new node.
</descr>
<seealso>
<link id="TAVLTree.NodeClass"/>
<link id="TAVLTree.Add"/>
<link id="TAVLTree.DisposeNode"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.NewNode.Result">
<short>The newly created tree node</short>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTree.DisposeNode">
<short>Dispose of a node outside of the tree</short>
<descr>
<var>DisposeNode</var> disposes of a node outside of the tree. 
If the node manager is set, the node is returned to the manager, otherwise it is freed.
Do not use this on a node that is still in the tree.
</descr>
<errors>
If use on a node in the tree, no error will happen, but the tree will no longer be correct and access violations may happen later on.
</errors>
<seealso>
<link id="TAVLTree.NewNode"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.DisposeNode.ANode">
<short>Node to dispose of</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.AddAscendingSequence">
<short></short>
<descr>
<p>
<var>AddAscendingSequence</var> is an optimized version of <link id="TAVLTree.Add">Add</link> 
for quickly adding an ascending sequence of  nodes. It adds <var>Data</var> between 
<var>LastAdded</var> and <var>Successor</var> as a state and skips searching for an insert position.
For nodes with same value the order of the sequence is kept. 
</p>
<p>
It can be used as follows:
</p>
<code>
LastNode:=nil; // TAvlTreeNode
Successor:=nil; // TAvlTreeNode
for i:=1 to 1000 do
 LastNode:=Tree.AddAscendingSequence(TItem.Create(i),LastNode,Successor);
</code>
<p>
If <var>LastAdded</var> is <var>Nil</var> a regular add is performed.
</p>
</descr>
<errors>
If the nodes are not in ascending order, the tree will not be consistent.
</errors>
<seealso>
<link id="TAVLTree.Add"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.AddAscendingSequence.Result">
<short>The newly inserted node</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.AddAscendingSequence.Data">
<short>Data to insert</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.AddAscendingSequence.LastAdded">
<short>Last added node. Must initially be Nil.</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.AddAscendingSequence.Successor">
<short>Successor node. Must initially be Nil.</short>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.Remove.Result">
<short><var>True</var> if the data was found and removed, <var>False</var> if not.</short>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.RemovePointer.Result">
<short><var>True</var> if the pointer was found and removed, <var>False</var> if not.</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.Equals">
<short>Check if two trees are equal</short>
<descr>
<var>Equals</var> checks, when passed an TAVLTtree, whether the tree is equal (using <link id="TAvlTree.IsEqual"/>, comparing keys only).
If another type of object is passed, the inherited <var>IsEqual</var> is called.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TAvlTree.IsEqual"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.Equals.Result">
<short>True if the passed object is an equal tree.</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.Equals.Obj">
<short>Object to compare</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.IsEqual">
<short>Check whether 2 tree instances are equal.</short>
<descr>
<var>IsEqual</var> checks the current tree with <var>aTree</var> and checks whether the two trees contain 
the same data in the same order  and whether they use the same compare methods, and node class.
If <var>CheckDataPointer</var> is <var>True</var>, only the data pointers are compared, not the keys.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TAvlTree.Equals"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.IsEqual.Result">
<short>True if both trees are equal.</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.IsEqual.aTree">
<short>Tree to compare with</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.IsEqual.CheckDataPointer">
<short>Should the data pointer be checked instead of the key ?</short>
</element>

<!-- procedure Visibility: public -->
<element name="TAVLTree.Assign">
<short>Assign another tree</short>
<descr>
<var>Assign</var> copies all data from <var>aTree</var> to the current tree if they are not equal. 
The current tree is cleared first. Note that the compare function(s) and class node are not copied, only the data.
</descr>
<errors>
If you pass nil, an exception is raised.
</errors>
<seealso>
<link id="TAVLTree.IsEqual"/>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.Assign.aTree">
<short>Tree to copy data from</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.Compare">
<short>Compare 2 nodes</short>
<descr>
<p>
<var>Compare</var> compares the keys from 2 data pointers. It uses the appropriate compare function <link id="TAVLtree.OnCompare"/> 
or <link id="TAVLTree.OnObjectCompare"/> to do so. The result is
</p>
<ul>
<li>negative if the first key comes before the second</li>
<li>0 when the two keys are equal.</li> 
<li>positive  if the second key comes before the first</li>
</ul>
</descr>
<seealso>
<link id="TAVLTree.OnObjectCompare"/> 
<link id="TAVLtree.OnCompare"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.Compare.Result">
<short>Result of the comparison</short>
</element>

 <!-- argument Visibility: default -->
<element name="TAVLTree.Compare.Data1">
<short>First data pointer</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.Compare.Data2">
<short>Second data pointer</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.FindNearestKey">
<short>Find nearest key for a data pointer</short>
<descr>
<var>FindNearestKey</var> attempts to find the nearest possible key in the tree using the <var>OnCompareKeyWithData</var> function.
It returns the closest possible key in the tree.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TAVLTree.FindKey"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.FindNearestKey.Result">
<short>The nearest possible key, if any</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindNearestKey.Key">
<short>Key to search with</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.FindNearestKey.OnCompareKeyWithData">
<short>Compare function</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.GetEnumeratorHighToLow">
<short>Return an enumerator that enumerates the tree in reversed order</short>
<descr>
<var>GetEnumeratorHighToLow</var> returns an enumerated that traverses the tree in reversed order.
</descr>
<errors>
</errors>
<seealso>
<link id="TAVLTree.GetEnumerator"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.GetEnumeratorHighToLow.Result">
<short>The enumerator</short>
</element>

<!-- function Visibility: public -->
<element name="TAVLTree.NodeToReportStr">
<short>Create a textual dump of the tree</short>
<descr>
<var>NodeToReportStr</var> creates a textual representation of a node. It is called by <link id="TAVLTree.ReportAsString"/> 
for debugging purposes. It prints the data pointer as a hex value. 
Override this to create a human-readable representation of the data.
</descr>
<seealso>
<link id="TAVLTree.ReportAsString"/>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="TAVLTree.NodeToReportStr.Result">
<short>The tree represented as a text</short>
</element>

<!-- argument Visibility: default -->
<element name="TAVLTree.NodeToReportStr.aNode">
<short>Node to start from</short>
</element>

<!-- "class of" type Visibility: default -->
<element name="TAVLTreeClass">
<short>Class of <var>TAVLTree</var></short>
<descr>
<var>TAVLTreeClass</var> is the class of <link id="TAVLTree"/>.
</descr>
<seealso>
<link id="TAVLTree"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="NodeMemManager">
<short>Default node manager</short>
<descr>
<var>NodeMemManager</var> is the default node manager for a new instance of <var>TAVLTree</var>.
</descr>
<seealso>
<link id="TAVLTree.SetNodeManager"/>
</seealso>
</element>

</module> <!-- AVL_Tree -->

</package>
</fpdoc-descriptions>
